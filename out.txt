Start.
Initializing graphics and camera.
Init camera output with 640/640
Creating pool with 3 buffers of size 614400
Camera successfully created
Compiled vertex shader ./shaders/auxiliary/vertices.glsl:
attribute vec4 vertex;
uniform vec2 offset;
uniform vec2 scale;
varying vec2 tcoord;
void main(void) 
{
	vec4 pos = vertex;
	tcoord.xy = pos.xy;
	pos.xy = pos.xy*scale+offset;
	gl_Position = pos;

}

Compiled fragment shader ./shaders/auxiliary/copy.glsl:
varying vec2 tcoord;
uniform sampler2D tex;
void main(void) 
{
    gl_FragColor = texture2D(tex,tcoord);
}

Compiled fragment shader ./shaders/auxiliary/yuvtorgba_dedonut.glsl:
varying vec2 tcoord;
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform sampler2D maptex;
void main(void) 
{
	float y = texture2D(tex0,texture2D(maptex,tcoord).rg).r;
	float u = texture2D(tex1,texture2D(maptex,tcoord).rg).r;
	float v = texture2D(tex2,texture2D(maptex,tcoord).rg).r;

	vec4 res;
	res.r = (y + (1.370705 * (v-0.5)));
	res.g = (y - (0.698001 * (v-0.5)) - (0.337633 * (u-0.5)));
	res.b = (y + (1.732446 * (u-0.5)));
	res.a = 1.0;

    gl_FragColor = clamp(res,vec4(0),vec4(1));
}

Compiled fragment shader ./shaders/auxiliary/dedonut.glsl:
varying vec2 tcoord;
uniform sampler2D tex;
uniform sampler2D maptex;
void main(void) 
{
	gl_FragColor = texture2D(tex,texture2D(maptex,tcoord).rg);
	//gl_FragColor = vec4(1.0,0.0,0.0,1.0);
	//gl_FragColor = texture2D(tex,tcoord);
}

Compiled fragment shader ./shaders/summer_hor.glsl:
/*
HORIZONTAL SUMMER SHADER
This comes after thresholding: its input is the texture which has the color-thresholded version of the input image. its output is a texture that has equal height as the input image, but only 1 pixel in width.
That is because we want to store the sums of each row in a single pixel.

WHAT SHOULD IT DO:
put the sum of each pixel row in a pixel of the output. Note that this is done in a normalized way: output 
between 0.0 and 1.0. This is because that is the only range we can put - 1.0 will become 255 when coming back
to the host. Therefore we normalize by dividing it by the total amount of pixels in the row.

HOW DOES IT WORK NOW:
Pretty straightforward: iterates over its row (remember that the shader is called once for each output pixel, so each shader call will be responsible for doing one row of summing) and stores the sum in RED component.
Right now it also stores a "boolean" value in the BLUE component: if the sum was nonzero, the blue is set to maximum. This is only so that we can easily see it on the preview screen, but serves no "real purpose"!

WHAT NEEDS TO BE DONE:
We will have separate summing of red and blue pixels in the threshold stage later. This should be adapted to also sum them separately.
*/

//VARYING AND UNIFORM VARIABLES: AUTOMATICALLY SET BEFORE STARTING (BY HOST OR VERTEX SHADER)
varying vec2 tcoord;		//gives our own coordinate as normalized floating point (x,y)
uniform sampler2D tex;		//thresholded input texture
uniform float hor_steps;	//the number of output pixels (needed to normalize the sum and iterate over pixels)

void main(void)
{
	//make the sum variable
	float sum = 0.0f;
	//calculate how big a "normalized floating point step" is that corresponds to moving to a
	//neighbouring pixel
	float step = 1.0f/hor_steps;
	//iterate over all source pixels using this step, summing their content
	int i = 0;
	for(;i<hor_steps;i++){
		sum = sum + texture2D(tex,vec2(step*i,tcoord[1])).r;
	}
	//normalize the sum to the total size
	float result = sum/hor_steps;
	//make the "boolean" (1.0 if sum was nonzero, otherwise 0.0)
	float found = 0.0f;
	if(result>0.0f){
		found = 1.0f;
	}
	//store the output pixel
	gl_FragColor = vec4(result,0.0f,found,1.0f);
}
Compiled fragment shader ./shaders/summer_ver.glsl:
/*
VERTICAL SUMMER SHADER

This is almost identical to the horizontal summer shader. Please see that one for comments and explanation.
*/

varying vec2 tcoord;
uniform sampler2D tex;
uniform float ver_steps;

void main(void)
{
	float sum = 0.0f;
	float step = 1.0f/ver_steps;
	int i = 0;
	for(;i<ver_steps;i++){
		sum = sum + texture2D(tex,vec2(tcoord[0],step*i)).r;
	}
	float result = sum/ver_steps;
    //gl_FragColor = vec4(result,0.0f,0.0f,0.0f);
	float found = 0.0f;
	if(result>0.0f){
		found = 1.0f;
	}
	gl_FragColor = vec4(result,0.0f,found,1.0f);
}
Compiled fragment shader ./shaders/thresholdshader.glsl:
/*
THRESHOLD SHADER
This is the first shader in the pipeline here (although on the pi it will be preceded by the one that does YUV->RGB and panoramic-making).
Its input is the RGBA, panoramic input image texture.

WHAT SHOULD IT DO:
It should give the texture which is ready to have the summation techniue applied: the color-thresholded texture. That means RGB->HSV transformation is needed, then some thresholding. But also, if needed, it should do pre-steps such as gaussian blur, erosion, etc to reduce noise. It doesn't do that at the moment.

HOW DOES IT WORK NOW:
remember that it is a shader: it gets called for every single output pixel. Since for this shader the output texture has the same dimensions as the input, it also corresponds to one INPUT pixel.
So all it does at the moment is:
- take its corresponding input pixel
- transform it to HSV
- do thresholding
- make the output pixel (gl_FragColor) white or black depending on the result.

WHAT NEEDS TO BE DONE:
First of all: right now this only thresholds one value (red), and makes the output white or black. We want to distinguish red and blue objects though. So what we could do is make two thresholds. We can store the results of both thresholds in the RED and BLUE components of the output pixel. So if a red object was found, the output pixel will become fully red, if a blue object was found, the output pixel will be fully BLUE.
Second: we need some filters to improve noise performance. You know this better than me! But likely we need gaussian blur and erosion. 
We should avoid re-inventing the wheel. The example code that the PI project was based on is here:
http://robotblogging.blogspot.nl/2013/10/gpu-accelerated-camera-processing-on.html
and the guy had already made GLSL shaders for erosion, gaussian blur and even sobel filtering. Re-use what can be re-used!
It would be great if we can integrate all those steps into this single shader, to avoid having to store even more textures in memory. But if it is impossible for some reason, you can ask me to add another rendering pipeline step(s) before or after this shader to do filtering.
*/

//VARYING AND UNIFORM VARIABLES: AUTOMATICALLY SET BEFORE STARTING (BY HOST OR VERTEX SHADER)
varying vec2 tcoord; //gives our own coordinate as normalized floating point (x,y)
uniform sampler2D tex; //input texture (panoramic camera image in RGBA)

vec3 rgb2hsv(vec3 c) //this function converts a vec3 pixel from RGB to HSV. (copied from example code)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c) //this function converts a vec3 pixel from HSV to RGB. (copied from example code)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 doThreshold(vec3 c) //this function does the thresholding on a RGB pixel, including HSV conversion.
{
    vec3 hsv = rgb2hsv(c);
    if((hsv[0] >= 0.85) && (hsv[0] <= 1.0) && (hsv[1] > 0.3) && (hsv[2] > 0.3)) return vec3(hsv[0], 1, 1);
    return c*vec3(0.0,0.0,0.0);
}

vec3 colorize(vec3 c) //unused right now: converts to HSV then back to RGB with maximum S and V ("colorize")
{
    vec3 hsv = rgb2hsv(c);
    return hsv2rgb(vec3(hsv[0], 1, 1));
}

vec3 colorizeSelect(vec3 c) //unused right now: colorize but with a brightness threshold included.
{
    vec3 hsv = rgb2hsv(c);
    if((hsv[1] > 0.15) && (hsv[2] > 0.3)) return hsv2rgb(vec3(hsv[0], 1, 1));
    return vec3(0,0,0);
}

//MAIN FUNCTION
void main(void)
{
    gl_FragColor = vec4(doThreshold(texture2D( tex, tcoord).rgb), texture2D(tex,tcoord).a);
	//gl_FragColor = vec4(colorizeSelect(texture2D( tex, tcoord).rgb), texture2D(tex,tcoord).a);
}
Compiled fragment shader ./shaders/coordinate.glsl:
/*
COORDINATE SHADER
This is the last shader in the pipeline.
It takes two input textures: hor_sum_tex ( 1xIMAGEHEIGHT pixels ) and ver_sum_tex (IMAGEWIDTHx1 pixels).
It assumes that in these textures, the sums of all rows (hor_sum_tex) and columns (ver_sum_tex) of the THRESHOLDED image have been stored.
More specifically: in the RED component of each pixel of these "summed textures".

WHAT SHOULD IT DO:
put coordinates of objects into the output texture. The output texture of this shader will be a certain width (100), and 1 pixel high. Each
pixel will store information about 1 object.

HOW DOES IT WORK NOW:
remember that it is a shader: assuming the output texture is 100 pixels wide, this shader will be called in parallel for each of these 100 pixels!
The current operation is this: there is a function nextObject() which finds the next possible object based on the summation textures. This way we
can "iterate through" all objects by calling it repeatedly.
The shader main function first finds out which pixel it is. For example, if we are the 5th output pixel, we should store information about the
5th found object. Therefore we call nextObject() 5 times and then return the information (by setting gl_FragColor). If at any point we reach the
end of the found objects we just return 0 for everything.
The information is stored as a RGBA vec4: (x_position, y_position, x_size, y_size) of the found object.

WHAT NEEDS TO BE DONE:
As said above, we assume that sums of thresholded image are stored in RED value of the sum textures. In the future we want to have separate summation values
for the "red-thresholded" and the "blue-thresholded" image. For example, we may want in the future to store the summation results for the blue-threshold in the
BLUE component of the thresholded image.
Then this shader should be able to deal with that accordingly, and somehow return information for RED and BLUE objects!
And of course, this implementation looks incredibly inefficient - there must be different ways to do it!
*/

//VARYING AND UNIFORM VARIABLES: AUTOMATICALLY SET BEFORE STARTING (BY HOST OR VERTEX SHADER)
varying vec2 tcoord; 			//gives our own coordinate as normalized floating point (x,y)
uniform sampler2D hor_sum_tex; 	//vertical texture of summed rows
uniform sampler2D ver_sum_tex; 	//horizontal texture of summed columns
uniform float num_coords; 		//total number of output pixels
uniform float hor_sum_height; 	//total number of summed rows
uniform float ver_sum_width;	//total number of summed columns

float x = 0.0f;
float y = 0.0f;

float foundx = 0.0f;
float foundwidth = 0.0f;
float foundy = 0.0f;
float foundheight = 0.0f;

float stepx = 1.0f/ver_sum_width;
float stepy = 1.0f/hor_sum_height;

int first = 1;

//A function that can be called repeatedly to "iterate over" objects.
//The first time it is called, it finds the first object on the x axis, then the first on the y axis. Subsequent calls
//will move to the next object on the Y axis, until the end is reached - then it will go back to the top and find the next
//one on the x axis.
int nextObject(void){
	int result = 0;

	//find first object on x axis
	if(first==1){
		for(; (x<=1.0f); x+=stepx){
			if(texture2D(ver_sum_tex,vec2(x,0.0f)).r > 0.0f){
				foundx = x; //note start
				for(; (x<=1.0f); x+=stepx) {
					if(texture2D(ver_sum_tex,vec2(x,0.0f)).r == 0.0f) break;
				}
				foundwidth = x - foundx; //note end
				result = 1;
				break;
			}
		}
		if(result == 0) return 0; //there are no objects.
		first = 0;
	}
	
	//go to start of next object on y axis
	for(; (y<=1.0f); y+=stepy){
		if(texture2D(hor_sum_tex,vec2(0.0f,y)).r > 0.0f){
			foundy = y; //note start
			for(; (y<=1.0f); y+=stepx) {
				if(texture2D(hor_sum_tex,vec2(0.0f,y)).r == 0.0f) break;
			}
			foundheight = y - foundy; //note end
			return 1; //we found a new object, return success.
			break;
		}
	}
	
	//we reached the end and found no more objects on y axis: move to next x axis object then and start over!
	result = 0;
	//search for next x object
	for(; (x<=1.0f); x+=stepx){
		if(texture2D(ver_sum_tex,vec2(x,0.0f)).r > 0.0f){
			foundx = x; //note start
			for(; (x<=1.0f); x+=stepx) {
				if(texture2D(ver_sum_tex,vec2(x,0.0f)).r == 0.0f) break;
			}
			foundwidth = x - foundx; //note end
			result = 1;
			break;
		}
	}
	if(result == 0) return 0; //no more objects
	
	//go to start of first object on y axis
	for(y=0.0f; (y<=1.0f); y+=stepy){
		if(texture2D(hor_sum_tex,vec2(0.0f,y)).r > 0.0f){
			foundy = y; //note start
			for(; (y<=1.0f); y+=stepx) {
				if(texture2D(hor_sum_tex,vec2(0.0f,y)).r == 0.0f) break;
			}
			foundheight = y-foundy; //note end
			return 1; //we found a new object, return success.
			break;
		}
	}	
	
	return 0; //no more objects at all.
}


//MAIN FUNCTION
void main(void)
{
	//find out "which pixel we are" by multiplying our normalized floating point coordinate (stored in tcoord) by the total number of pixels (stored in num_coords).
	float my_num = (tcoord[0]*num_coords);
	//now iterate over objects until we reach the one "with our index" (the one we should provide information about)
	float i;
	for(i=0; i<my_num; i=i+1.0f){
		if(nextObject() == 0) return;
	}
	
	//now store the object information in our output pixel
	gl_FragColor = vec4(foundx,foundy,foundwidth,foundheight);
}
Created program id 9 from vs 1 and fs 2
9:program:

Created program id 10 from vs 1 and fs 3
10:program:

Created program id 11 from vs 1 and fs 4
11:program:

Created program id 12 from vs 1 and fs 5
12:program:
ERROR:LEX/PARSE-1 (fragment shader, line 27) Syntax error
Created program id 13 from vs 1 and fs 6
13:program:
ERROR:LEX/PARSE-1 (fragment shader, line 13) Syntax error
Created program id 14 from vs 1 and fs 7
14:program:

Created program id 15 from vs 1 and fs 8
15:program:
ERROR:LEX/PARSE-1 (fragment shader, line 37) Syntax error
Camera resolution: 640x640
Creating Textures.
Max texture size: 3379
Dedonut: 2010x153
Starting process loop.
[?1049h[1;49r(B[m[4l[?7h[?1h=[H[2J