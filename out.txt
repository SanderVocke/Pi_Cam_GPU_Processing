Init camera output with 640/640
Creating pool with 3 buffers of size 614400
Camera successfully created
Compiled vertex shader ./shaders/vertex.glsl:
attribute vec4 vertex;
uniform vec2 offset;
uniform vec2 scale;
void main(void) 
{
	vec4 pos = vertex;
	pos.xy = pos.xy*scale+offset;
	gl_Position = pos;
}
Compiled vertex shader ./shaders/auxiliary/vertices.glsl:
attribute vec4 vertex;
uniform vec2 offset;
uniform vec2 scale;
varying vec2 tcoord;
void main(void) 
{
	vec4 pos = vertex;
	tcoord.xy = pos.xy;
	pos.xy = pos.xy*scale+offset;
	gl_Position = pos;

}

Compiled fragment shader ./shaders/auxiliary/copy.glsl:
varying vec2 tcoord;
uniform sampler2D tex;
void main(void) 
{
    gl_FragColor = texture2D(tex,tcoord);
}

Compiled fragment shader ./shaders/auxiliary/yuvtorgba_dedonut.glsl:
varying vec2 tcoord;
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform sampler2D maptex;
void main(void) 
{
	float y = texture2D(tex0,texture2D(maptex,tcoord).rg).r;
	float u = texture2D(tex1,texture2D(maptex,tcoord).rg).r;
	float v = texture2D(tex2,texture2D(maptex,tcoord).rg).r;

	vec4 res;
	res.r = (y + (1.370705 * (v-0.5)));
	res.g = (y - (0.698001 * (v-0.5)) - (0.337633 * (u-0.5)));
	res.b = (y + (1.732446 * (u-0.5)));
	res.a = 1.0;

    gl_FragColor = clamp(res,vec4(0),vec4(1));
}

Compiled fragment shader ./shaders/summer_hor.glsl:
//VARYING AND UNIFORM VARIABLES: AUTOMATICALLY SET BEFORE STARTING (BY HOST OR VERTEX SHADER)
varying vec2 tcoord;		//gives our own coordinate as normalized floating point (x,y)
uniform sampler2D tex;		//thresholded input texture
uniform float step;

void main(void)
{
	//make the sum variable
	float sum_red	= 0.0;
	float sum_blue	= 0.0;
	float pos = tcoord[0]-step;
	vec4 pixel;
	//iterate over 64 source pixels using this step, summing their content	
	for(int i=0;i<64;i++){
		pixel = texture2D(tex,vec2(pos,tcoord[1]));	
		sum_red = sum_red + pixel.r;
		sum_blue = sum_blue + pixel.b;
		pos = pos + step;
	}

	float result_red = sum_red/32.0;
	float result_blue = sum_blue/32.0;
	
	//store the output pixel
	//gl_FragColor = vec4(result,0.0,0.0,1.0);
	gl_FragColor = vec4(result_red>0.0?1.0:0.0,0.0,result_blue>0.0?1.0:0.0,1.0);
}

Compiled fragment shader ./shaders/summer_ver.glsl:
/*
VERTICAL SUMMER SHADER

This is almost identical to the horizontal summer shader. Please see that one for comments and explanation.
*/

varying vec2 tcoord;
uniform sampler2D tex;
uniform float step;

void main(void)
{
	//make the sum variable
	float sum_red = 0.0;
	float sum_blue = 0.0;
	float pos = tcoord[1]-step;
	vec4 pixel;
	//iterate over 64 source pixels using this step, summing their content	
	for(int i=0;i<64;i++){
		pixel = texture2D(tex,vec2(tcoord[0],pos));	
		sum_red = sum_red + pixel.r;
		sum_blue = sum_blue + pixel.b;
		pos = pos + step;
		
	}
	
	float result_red = sum_red/32.0;
	float result_blue = sum_blue/32.0;
	//store the output pixel
	//gl_FragColor = vec4(result,0.0,0.0,1.0);
	gl_FragColor = vec4(result_red>0.0?1.0:0.0,0.0,result_blue>0.0?1.0:0.0,1.0);
}

Compiled fragment shader ./shaders/thresholdshader.glsl:
//VARYING AND UNIFORM VARIABLES: AUTOMATICALLY SET BEFORE STARTING (BY HOST OR VERTEX SHADER)
varying vec2 tcoord; //gives our own coordinate as normalized floating point (x,y)
uniform sampler2D tex; //input texture (panoramic camera image in RGBA)

vec3 rgb2hsv(vec3 c) //this function converts a vec3 pixel from RGB to HSV. (copied from example code)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c) //this function converts a vec3 pixel from HSV to RGB. (copied from example code)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 doThreshold(vec3 hsv) //this function does the thresholding on a RGB pixel, including HSV conversion.
{
    vec3 outThreshold;
	outThreshold	= vec3(0.0,0.0,0.0);
    if((hsv[0] >= 0.85) && (hsv[0] <= 1.0) && (hsv[1] > 0.3) && (hsv[2] > 0.3)) outThreshold[0] = 1.0;
	if((hsv[0] >= 0.40) && (hsv[0] <= 0.85) && (hsv[1] > 0.3) && (hsv[2] > 0.3)) outThreshold[2] = 1.0;
	return outThreshold;
}

vec3 colorize(vec3 c) //unused right now: converts to HSV then back to RGB with maximum S and V ("colorize")
{
    vec3 hsv = rgb2hsv(c);
    return hsv2rgb(vec3(hsv[0], 1, 1));
}

vec3 colorizeSelect(vec3 c) //unused right now: colorize but with a brightness threshold included.
{
    vec3 hsv = rgb2hsv(c);
    if((hsv[1] > 0.15) && (hsv[2] > 0.3)) return hsv2rgb(vec3(hsv[0], 1, 1));
    return vec3(0,0,0);
}

//MAIN FUNCTION
void main(void)
{
    vec3 hsv = rgb2hsv(texture2D( tex, tcoord).rgb);
	gl_FragColor = vec4(doThreshold(hsv), texture2D(tex,tcoord).a);
	//gl_FragColor = vec4(colorizeSelect(texture2D( tex, tcoord).rgb), texture2D(tex,tcoord).a);
}

Compiled fragment shader ./shaders/erodefragshader_ours.glsl:
varying vec2 tcoord;
uniform sampler2D tex;
uniform vec2 texelsize;
void main(void) 
{
	//vec4 col = vec4(1);
	//for(int xoffset = -3; xoffset <= 4; xoffset++)
	//{
	//	for(int yoffset = -3; yoffset <= 4; yoffset++)
	//	{
	//		vec2 offset = vec2(xoffset,yoffset);
	//		col = min(col,texture2D(tex,tcoord+offset*texelsize));
	//	}
	//}
    //gl_FragColor = clamp(col,vec4(0),vec4(1));
	
	float xoffset, yoffset;
	xoffset = -3.0f*texelsize.x+tcoord.x;
	yoffset = -3.0f*texelsize.y+tcoord.y;
	vec4 col = vec4(1);
	for(int i=0; i<1; i++)
	{
		for(int j=0; j<1; j++)
		{
			col = min(col,texture2D(tex,vec2(xoffset,yoffset)));			
		}
	}
    gl_FragColor = clamp(col,vec4(0),vec4(1));
}

Compiled fragment shader ./shaders/dilatefragshader_ours.glsl:
varying vec2 tcoord;
uniform sampler2D tex;
uniform vec2 texelsize;
void main(void) 
{
	vec4 col = vec4(0);
	for(int xoffset = -3; xoffset <= 4; xoffset++)
	{
		for(int yoffset = -3; yoffset <= 4; yoffset++)
		{
			vec2 offset = vec2(xoffset,yoffset);
			col = max(col,texture2D(tex,tcoord+offset*texelsize));
		}
	}
    gl_FragColor = clamp(col,vec4(0),vec4(1));
}

Compiled fragment shader ./shaders/color.glsl:
uniform vec4 color;

void main(void)
{
	gl_FragColor = color;
}

Created program id 11 from vs 2 and fs 3
11:program:

Created program id 12 from vs 2 and fs 4
12:program:

Created program id 13 from vs 2 and fs 5
13:program:

Created program id 14 from vs 2 and fs 6
14:program:

Created program id 15 from vs 2 and fs 7
15:program:

Created program id 16 from vs 2 and fs 8
16:program:
ERROR:LEX/PARSE-1 (fragment shader, line 18) Syntax error
Created program id 17 from vs 2 and fs 9
17:program:

Created program id 18 from vs 1 and fs 10
18:program:

[?1049h[1;24r(B[m[4l[?7h[?1h=[H[2J